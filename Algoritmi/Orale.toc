\contentsline {section}{\numberline {1}Complessità problema}{1}{section.1}%
\contentsline {section}{\numberline {2}Cos'è un heap, complessità ricerca massimo}{1}{section.2}%
\contentsline {section}{\numberline {3}Metodo del limite e dimostrazione}{1}{section.3}%
\contentsline {section}{\numberline {4}Definizione albero binario, BST, complessità ricerca}{1}{section.4}%
\contentsline {section}{\numberline {5}Dimostrazione che il limite degli ordinamenti è nlogn}{2}{section.5}%
\contentsline {section}{\numberline {6}Complessità quicksort e spiegazione breve algoritmo, caso medio, peggiore e perché tante ripartizioni sono caso medio}{2}{section.6}%
\contentsline {section}{\numberline {7}Counting sort, perché non si può usare sempre per ottenere ordinamento lineare, condizione affinché $ \Theta $(n), Radix Sort}{3}{section.7}%
\contentsline {section}{\numberline {8}Tabella hash: complessità inserimento e rimozione, chaining e open addressing}{4}{section.8}%
\contentsline {section}{\numberline {9}Doppio hashing (come scegliere le funzioni)}{4}{section.9}%
\contentsline {section}{\numberline {10}Max-heap e heapsort}{4}{section.10}%
\contentsline {section}{\numberline {11}Funzionamento e complessita maxHeapify e buildMaxHeap, complessità inserimento}{5}{section.11}%
\contentsline {section}{\numberline {12}Cos'è heap, complessità insert in heap}{6}{section.12}%
\contentsline {section}{\numberline {13}Definizione di RB-Tree e costo inserimento}{7}{section.13}%
\contentsline {subsection}{\numberline {13.1}Definizione funzioni}{8}{subsection.13.1}%
\contentsline {section}{\numberline {14}Perché preferire BST a tabelle hash}{11}{section.14}%
\contentsline {section}{\numberline {15}Definizione di sottostringa e sottosequenza e numero di sottostringe e sottosequenze in una stringa}{11}{section.15}%
\contentsline {section}{\numberline {16}Diversi tipi di ordine per calcolare elementi nella programmazione dinamica}{12}{section.16}%
\contentsline {section}{\numberline {17}Generico algoritmo top down memoizzato}{12}{section.17}%
\contentsline {section}{\numberline {18}Codici di Huffman}{13}{section.18}%
\contentsline {section}{\numberline {19}Quale tra gli esercizi di programmazione dinamica svolti a lezione non si risolveva solo risolvendo sottoproblemi}{13}{section.19}%
\contentsline {section}{\numberline {20}Definizione e vantaggi della memoizzazione}{13}{section.20}%
\contentsline {section}{\numberline {21}Codici Prefisso}{14}{section.21}%
\contentsline {section}{\numberline {22}Scansione riempimento della tabella di LCS}{14}{section.22}%
\contentsline {section}{\numberline {23}Differenza tra approccio top-down e bottom-up per la programmazione dinamica. Vantaggi e svantaggi di entrambi}{15}{section.23}%
